import{_ as d,c as i,a as n,b as l,d as a,e as t,w as p,r,o}from"./app-yZ_05sAe.js";const c={};function h(m,e){const s=r("font");return o(),i("div",null,[e[6]||(e[6]=n('<h1 id="mysql体系结构和存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql体系结构和存储引擎"><span>MySQL体系结构和存储引擎</span></a></h1><h2 id="mysql体系结构" tabindex="-1"><a class="header-anchor" href="#mysql体系结构"><span>MySQL体系结构</span></a></h2><p>数据库是由一个一个的文件组成的，而对实际的数据进行增删改查的操作则需要数据库实例来完成。</p><p>MySQL数据库体系结构图如下所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/387a91fd2b85b6085445060ddf61ce96.png" alt=""></p>',5)),l("p",null,[e[1]||(e[1]=t("⭐MySQL的数据库的存储引擎是插件式的，每个存储引擎的开发者都可以按照它的标准去实现自定义的存储引擎。值得注意的是：")),a(s,{title:"red"},{default:p(()=>e[0]||(e[0]=[t("存储引擎是基于表的，而不是基于数据库的")])),_:1}),e[2]||(e[2]=t("。"))]),e[7]||(e[7]=n(`<blockquote><p>MySQL可以使用内部查询缓存（Caches）来查看是否可以直接提供结果，但随着并发性的增加，查询缓存成为了瓶颈。从MySQL 5.7.20版本开始，查询缓存已经被标注为废弃的特性，并且在8.0版本中被完全移除。</p></blockquote><h2 id="mysql的存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql的存储引擎"><span>MySQL的存储引擎</span></a></h2><p>MySQL的存储引擎分为官方的存储引擎的和第三方的存储引擎，其中InnoDB一开始就是第三方存储引擎，后被Oracle收购了。</p><p>其中常见的存储引擎比较如下表所示：</p><table><thead><tr><th>特点</th><th>MyISAM</th><th>Memory</th><th>InnoDB</th><th>Archive</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td></td><td>是</td><td>64TB</td><td></td><td>是</td></tr><tr><td>支持事务</td><td></td><td></td><td>是</td><td></td><td>是</td></tr><tr><td>锁粒度</td><td>表锁</td><td>表锁</td><td>行锁</td><td>行锁</td><td>行锁</td></tr><tr><td>MVCC/快照读</td><td></td><td></td><td>是</td><td>是</td><td>是</td></tr><tr><td>地理数据类型</td><td>是</td><td></td><td></td><td></td><td></td></tr><tr><td>B-Tree索引</td><td>是</td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>Hash索引</td><td></td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>全文索引</td><td>是</td><td></td><td></td><td></td><td></td></tr><tr><td>聚集索引</td><td></td><td></td><td>是</td><td></td><td></td></tr><tr><td>数据加密</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>数据缓存</td><td></td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>索引缓存</td><td></td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>数据压缩</td><td>是</td><td></td><td></td><td>是</td><td></td></tr><tr><td>存储消耗</td><td>低</td><td>N/A</td><td>高</td><td>非常低</td><td>低</td></tr><tr><td>批量插入速度</td><td>高</td><td>高</td><td>低</td><td>非常高</td><td>高</td></tr><tr><td>集群数据库</td><td></td><td></td><td></td><td></td><td>是</td></tr><tr><td>支持复制</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>外键支持</td><td></td><td></td><td>是</td><td></td><td></td></tr><tr><td>备份/恢复</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>查询缓存</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h3 id="innodb与mysiam之间的区别" tabindex="-1"><a class="header-anchor" href="#innodb与mysiam之间的区别"><span>InnoDB与MySIAM之间的区别</span></a></h3><p>⭐事务支持</p><ul><li><p>InnoDB</p><p>1️⃣完全支持ACID事务（<em>原子性、一致性、隔离性和持久性</em>）；</p><p>2️⃣支持四种隔离级别（<em>读未提交、读已提交、可重复读和序列化</em>），默认隔离级别可重复读。</p><p>3️⃣支持事务回滚和崩溃恢复；</p></li><li><p>MyISAM</p><p>1️⃣不支持事务；</p><p>2️⃣所有操作都是自动提交；</p><p>3️⃣不适合需要事务处理的业务场景；</p></li></ul><p>⭐锁支持</p><ul><li><p>InnoDB</p><p>1️⃣行级锁（<em>某些情况下会升级为表锁</em>）；</p><p>2️⃣支持意向锁（<em>共享锁和排他锁</em>）；</p><p>3️⃣并发性能姮好，适合高并发读写场景；</p><p>4️⃣锁粒度更细，可以减少锁冲突；</p></li><li><p>MyISAM</p><p>1️⃣表级锁（读锁和写锁）；</p><p>2️⃣写操作会阻塞所有的读操作和写操作；</p><p>3️⃣读操作之间不阻塞，但会阻塞写操作；</p><p>4️⃣并发性能较差，适合读多写少的场景；</p></li></ul><p>⭐数据完成性</p><ul><li><p>InnoDB</p><p>1️⃣支持外键约束；</p><p>2️⃣自动维护参照完整性；</p><p>3️⃣支持级联操作（ON DELETE/UPDATE CASCADE等）；</p></li><li><p>MyISAM</p><p>1️⃣不支持外键；</p><p>2️⃣没有参照完整性检查；</p><p>3️⃣需要应用层自行维护数据关系；</p></li></ul><p>⭐存储结构</p><ul><li><p>InnoDB</p><p>1️⃣数据和索引存储在同一个文件中（<code>.idb</code>文件）；</p><p>2️⃣使用聚簇索引，主键索引的叶子节点存储数据行；</p><p>3️⃣支持自适应Hash索引；</p><p>4️⃣支持崩溃恢复机制；</p></li><li><p>MyISAM</p><p>1️⃣数据和索引分开存储（<code>.myd</code>存储数据，<code>.myi</code>存储索引）；</p><p>2️⃣使用非聚簇索引，索引叶子节点存储数据行的指针；</p><p>3️⃣不支持崩溃恢复（需要手动修复）；</p></li></ul><p>⭐性能特点</p><ul><li>InnoDB —— 写入性能较好，适合频繁更新的场景。随着数据量增大，性能下降较慢。需要更多的内存来作为缓冲池。</li><li>MyISAM —— 读取性能较好，适合多读少写的场景。随着数据增大，性能下降较快。内存占用相对较少。</li></ul><p>⭐备份与恢复</p><ul><li>InnoDB —— 支持热备份、增量备份，恢复机制完善；</li><li>MyISAM —— 备份时需要锁定表，不支持热备份，恢复比较麻烦；</li></ul><p>⭐其它特性</p><ul><li>InnoDB —— 支持全文索引、支持压缩表、支持空间索引、表空间可以管理；</li><li>MyISAM —— 原生支持全文索引，不支持压缩表，不支持GIS数据，表空间固定；</li></ul><h1 id="innodb存储引擎" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎"><span>InnoDB存储引擎</span></a></h1><h2 id="innodb存储引擎体系结构" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎体系结构"><span>InnoDB存储引擎体系结构</span></a></h2><p>后台线程的作用：负责刷新内存池中的数据。主要包含将最新的数据加载到内存中和将最近修改的数据刷新到磁盘上。</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250505180902737.png" alt="image-20250505180902737"></p><h3 id="后台线程" tabindex="-1"><a class="header-anchor" href="#后台线程"><span>后台线程</span></a></h3><p>InnoDB存储引擎后台是多线程的模型，所以在它的后台不同的线程负责不同的任务。</p><ul><li><p>Master Thread</p><p>主要负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性，它包括了：脏页的刷新、合并插入缓冲以及UNDO页的回收等。</p></li><li><p>IO Thread</p><p>主要使用AIO来处理IO请求，IO Thread主要负责此类IO请求的回调。</p></li><li><p>Purge Thread</p><p>主要负责在事务提交后来回收已经使用并分配的undo页。</p></li></ul><p>在InnoDB的1.0版本中，purge操作由Master Thread来完成，而在1.1版本之后，purge可以由独立的线程来完成，以此来降低Master Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。可以使用如下的配置来开启Purge Thread。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span></span>
<span class="line">innodb_purge_thread<span class="token operator">=</span><span class="token number">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="内存" tabindex="-1"><a class="header-anchor" href="#内存"><span>内存</span></a></h3><h4 id="缓冲池" tabindex="-1"><a class="header-anchor" href="#缓冲池"><span>缓冲池</span></a></h4><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。</p><ul><li><p>读操作</p><p>在读取数据库中的数据时，通常也是以页为单位来读取的。每次读取的时候会先查看缓冲池中是否存在当前页，如果存在就直接返回；反之，则从磁盘中读取对应的数据。</p></li><li><p>写操作</p><p>在修改数据库中的数据时，不会去直接修改磁盘上的数据，而是先修改缓冲池中对应页的数据，然后再按照一定频率将缓冲池中的数据刷新到磁盘上。</p></li></ul><p>⭐<strong>缓冲池中的数据类型</strong></p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250506211444333.png" alt="image-20250506211444333"></p><p>InnoDB的缓冲池中，<span alt="solid">数据页和索引页占据了大部分的内存空间</span>。除此之外还有：插入缓冲、自适应Hash索引、锁信息和数据字典信息等。</p><blockquote><p>从InnoDB 1.x版本开始支持有多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例中。</p></blockquote><p>⭐<strong>缓冲池中的数据管理方案</strong></p>`,38)),a(s,{title:"gray"},{default:p(()=>e[3]||(e[3]=[t("LRU（Latest Recent Used，最近最少使用）算法")])),_:1}),e[8]||(e[8]=n('<p>InnoDB中并没有采用朴素的LRU算法，而是设置了midpoint（中点位），在默认情况下midpoint设置为列表长度的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>5</mn></mrow><mrow><mn>8</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\\frac{5}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">8</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">5</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>的位置。在InnoDB中midpoint之前的列表称之为new列表（<em>简单理解为热点数据</em>），之后的列表则称之为old列表。</p><p>与朴素LRU算法的区别：</p><ol><li>每次新被读取的页并不会放置到列表的首个位置，而是放置在midpoint位置；</li><li>处于midpoint位置的页会在一个固定的时间后加入到LRU队列的new列表中；</li></ol><p>这样的改进是为了<span alt="solid">避免某些索引或者数据的扫描操作将热点数据刷出了LRU列表</span>，例如在某一次查询中需要加载大量的页到缓冲池中，但是仅仅只在这一次查询中生效，如果直接放到LRU列表的首个位置，则会导致真正的热点数据被刷出了LRU列表。</p>',4)),a(s,{title:"gray"},{default:p(()=>e[4]||(e[4]=[t("Free List")])),_:1}),e[9]||(e[9]=l("p",null,"在InnoDB存储引擎中首次加载的时候LRU列表是空的，此时页都存放在Free List中。当需要从缓冲池中需要新增一个页的时候，首先在Free List中找是否有可用的空闲页，如果有则将该页从Free List中删除，将其加入到LRU列表中；如果没有，则根据LRU列表的淘汰策略，将LRU列表末尾的页分配给新的页。",-1)),a(s,{title:"gray"},{default:p(()=>e[5]||(e[5]=[t("Flush List")])),_:1}),e[10]||(e[10]=n(`<p>当LRU列表中的页被修改时，则称该页为“脏页”（<em>缓冲池中的数据与磁盘上的数据不一致</em>），脏页不仅在LRU列表中，也存在于Flush List中。数据库会通过CheckPoint机制将Flus List中的数据刷新到磁盘上。</p><blockquote><p>LRU列表用来管理缓冲池中页的可用性，Flus List用于记录与磁盘上数据不一致的页。两个列表中都有脏页，是不互相冲突的。</p></blockquote><h4 id="重做日志缓冲" tabindex="-1"><a class="header-anchor" href="#重做日志缓冲"><span>重做日志缓冲</span></a></h4><p>InnoDB存储引擎首先将重做日志信息放入到这个缓冲区，然后再按照一定的频率将其刷新到重做日志文件中。除了按照一定的频率外，还有三种情况也会触发将日志缓冲刷新到文件中：</p><ol><li>Master Thread 每秒将重做日志缓冲刷新到重做日志文件中；</li><li>每个事务提交时会将重做日志缓冲刷新到重做日志文件中；</li><li>当重做日志缓冲池剩余空间不足50%的时候，重做日志缓冲会被刷新到重做日志文件中；</li></ol><h4 id="额外内存池" tabindex="-1"><a class="header-anchor" href="#额外内存池"><span>额外内存池</span></a></h4><p>额外的内存池主要是记录一些数据结构本身的信息，例如缓冲池的帧缓冲和对应的缓冲控制对象等。当需要申请很大的InnoDB缓冲池时，也需要相应的考虑扩大额外内存池的大小。</p><h2 id="checkpoint技术" tabindex="-1"><a class="header-anchor" href="#checkpoint技术"><span>CheckPoint技术</span></a></h2><p>为了提高数据库的性能和稳定性，缓冲池避免了频繁对磁盘进行读取或写入操作，但并不能保证数据库在宕机之后能够恢复。</p><p>目前的事务型数据库，都采取了Write Ahead Log，即当事务提交时，先写重做日志，再修改页中的数据。此时如果宕机了，可以通过重做日志来恢复数据。</p><p>在实际的条件下，缓冲池并不能无限大，重做日志也无法无限大，所以将数据缓冲和日志缓冲刷新到磁盘中是必须要执行的操作。</p><p><span alt="solid">CheckPoint就是用来保障将数据缓存和日志缓存正确的刷新到磁盘上的一项技术</span>。</p><p><strong>它主要用来解决下面的是三个问题：</strong></p><p>1️⃣缩短数据库的恢复时间；</p><p>2️⃣缓冲池不够用的时候，将脏页刷新到磁盘。</p><p>通过LRU算法的淘汰策略，选出需要被淘汰的页。如果当前页为脏页，则会被强制执行CheckPoint，即将脏页中的数据刷新到磁盘上。</p><p>3️⃣重做日志不可用的时候，刷新脏页；</p><p>当重做日志不可用的时候，依赖这些重做日志无法完全恢复数据，则会强制执行CheckPoint，将脏页中的数据刷新到磁盘上来防止数据库宕机后，缓冲池中的数据与磁盘上的数据不一致的情况。</p><blockquote><p>重做日志不可用可能发生的情况：</p><ol><li>日志损坏：因为硬件故障、磁盘错误或软件Bug，导致无法读取或者解析；</li><li>日志空间耗尽：因为系统异常导致重做日志无法正常循环，导致日志文件不断增大；</li><li>数据不一致：在数据库的恢复过程中发现重做日志中与数据文件不一致，即使用重做日志无法恢复数据。</li></ol></blockquote><h3 id="innodb中checkpoint触发" tabindex="-1"><a class="header-anchor" href="#innodb中checkpoint触发"><span>InnoDB中CheckPoint触发</span></a></h3><p>首先说到在InnoDB中存在两种CheckPoint：</p><ol><li>Sharp CheckPoint —— 将所有的脏页都刷新到磁盘中；</li><li>Fuzzy CheckPoint —— 将部分的脏页刷新到磁盘中；</li></ol><p>其中第一个Sharp CheckPoint发生在数据库关闭的时候，第二个Fuzzy CheckPoint则发生在数据库运行时。</p><p>InnoDB中发生Fuzzy CheckPoint有以下几种情况：</p><ul><li><p>Master Thread CheckPoint</p><p>Master Thread按照固定的频率将缓冲池中一定比例的脏页刷新到磁盘上。</p></li><li><p>FLUSH_LRU_LIST CheckPoint</p><p>为了保证LRU列表中有100个空闲页可用，会根据LRU列表的淘汰策略选择需要被淘汰的页，如果该页为脏页，就会被强制刷新磁盘上。</p></li><li><p>Async/Sync Flush CheckPoint</p><p>当日志不可用时，会从Flush List中选择一部分的脏页刷新到磁盘上。至于采用Async的方式刷新，还是采用Sync的方式刷新，则根据CheckPoint的LSN(<em>页版本号</em>)和重做日志的LSN来决定。</p></li><li><p>Dirty Page too much CheckPoint</p><p>当缓冲池中脏页的比例太多的时候，也会被强制执行CheckPoint技术。</p></li></ul><h2 id="innodb的关键特性" tabindex="-1"><a class="header-anchor" href="#innodb的关键特性"><span>InnoDB的关键特性</span></a></h2><h3 id="插入缓冲" tabindex="-1"><a class="header-anchor" href="#插入缓冲"><span>插入缓冲</span></a></h3><p>Insert Buffer的出现主要是为了解决：<span alt="solid">提高非聚集索引插入的性能</span>。</p><p>对于非聚集索引的插入或更新操作，先判断要插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率或在特定的情况下将Insert Buffer和辅助索引的叶子节点进行合并操作（<em>可以将多个插入操作合并为一个插入操作</em>）。</p><p>使用Insert Buffer需要满足两个条件：</p><p>🅰️索引是辅助索引；</p><p>🅱️索引不能是唯一的；</p><blockquote><p>为什么索引不能是唯一的？</p><p>如果索引是唯一的，此时插入一条数据，数据库需要去查找索引页来判断数据的唯一性。在查找索引的过程中肯定又会发生离散读取的情况，也就导致了Insert Buffer失去了意义。</p></blockquote><p><span alt="solid">Insert Buffer的数据结构是一颗B+树</span>，因此也是由叶子节点和非叶子节点组成。</p><p>⭐非叶子节点</p><p>非叶子节点存放的是查询的Search Key，由三部分组成：space、marker和offset。</p><ul><li>space —— 表示待插入记录所在表空间的id，占据4个字节；</li><li>marker —— 兼容老版本的Insert Buffer，占据1个字节；</li><li>offset —— 表示页所在的偏移量，占据4个字节；</li></ul><p>⭐叶子节点</p><p>当一个辅助索引需要插入到页时，如果这个页不在缓冲池中，那么首先会构造一个Search key，然后查询Insert Buffer这棵树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。</p><p>叶子节点也有三部分组成：Search Key（<em>包含space、marker和offer</em>）、metadata和记录的相关信息。</p><p>其中Search Key的含义与非叶子节点中Search Key的含义相同，metadata用来标识每个记录进入Insert Buffer的顺序。</p><h4 id="merge-insert-buffer" tabindex="-1"><a class="header-anchor" href="#merge-insert-buffer"><span>Merge Insert Buffer</span></a></h4><p>Merge Insert Buffer是指将Insert Buffer中的数据合并到真正的索引页中，在合并的时候可能出现以下的情况：</p><p>1️⃣辅助索引页被读取到缓冲池中</p><p>在执行一些常规的查询操作时，我们可能需要将原本不在缓冲池中的索引页读取到缓冲池中，此时会通过Insert Buffer Bitmap来判断当前索引页是否在Insert Buffer B+树中存在未合并的数据，若是，则将数据合并到该索引页中。</p><blockquote><p>Insert Buffer Bitmap 是用来追踪每个辅助索引页的可用空间的。</p></blockquote><p>2️⃣Insert Buffer Bitmap 页追踪到该辅助索引页已无可用空间</p><p>Insert Buffer Bitmap 在追踪每个辅助索引页的时候，如果发现某个辅助索引页的可用空间小于了1/32页，则会强制读取辅助索引页，将Insert Buffer B+树中该页的记录以及待插入的记录插入到该辅助索引页中。</p><p>3️⃣Master Thread</p><p>Master Thread线程中每秒或者每十秒都会进行一次Merge Insert Buffer的操作，二者的差距在于merge页的数量不同。</p><h3 id="两次写" tabindex="-1"><a class="header-anchor" href="#两次写"><span>两次写</span></a></h3><p>两次写的目的是为了提高数据的可靠性。在InnoDB存储引擎中，doublewrite的体系架构图如下：</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250507230657563.png" alt="image-20250507230657563"></p><p>doublewrite由两部分组成：内存中的doublewrite buffer和磁盘上共享表空间中连续的128个页（<em>2个区，2MB</em>）。</p><p>当需要将缓冲池中的脏页刷新到磁盘上时，并不是直接将数据写入磁盘的。</p><p>1️⃣首先将数据脏页复制到内存中的doublewrite buffer中；</p><p>2️⃣doublewrite buffer分两次，每次按照1MB的顺序将数据写入到共享表空间的物理磁盘中；</p><p>3️⃣doublewrite buffer将数据同步到磁盘上；</p><p>如果在将某个页写入到表中的时只写入了一部分，数据库就发生了宕机，在没有doublewrite的情况下， 这个页就部分失效了；反之，在有doublewrite的情况下，可以利用共享表空间的doublewrite来回复这个页。</p><p>简而言之，两次写在共享表空间中创建一个备份，在主数据发生损坏的时候，可以通过共享表空间中的备份来恢复数据。</p><h3 id="自适应hash索引" tabindex="-1"><a class="header-anchor" href="#自适应hash索引"><span>自适应Hash索引</span></a></h3><p>InnoDB存储引擎会监控各个索引页的查询，如果建立hash索引可以带来速度提升，则建立hash索引，称之为自适应hash索引。</p><p>InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点数据建立哈希索引，其中要求每次访问的模式必须是一样的（<em>意思就是查询条件是一样的</em>）。</p><p>例如对于联合索引<code>(a,b)</code>而言，我们通过下面两种方式去访问：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">where</span> a <span class="token operator">=</span> xxx<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">where</span> a<span class="token operator">=</span> xxx <span class="token operator">and</span> b<span class="token operator">=</span>xxx<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果每次的查询是上述两种交替出现，InnoDB存储引擎则不会为这个索引页创建AHI（Adaptive Hash Index，自适应Hash索引）。</p><p>对于同一个访问模式而言，它还需要满足下面的条件：</p><ul><li>以该模式访问了100次；</li><li>页通过该模式访问了N次，其中N 为页中数据总量的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>1</mn><mn>6</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\\frac{1}{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>；</li></ul><h3 id="异步io" tabindex="-1"><a class="header-anchor" href="#异步io"><span>异步IO</span></a></h3><p>为了提高磁盘的操作性能，InnoDB存储引擎采用的AIO的方式对磁盘进行读写。</p><p>AIO的第一个优点就是它是非阻塞的，可以在发出一次IO请求后再次发出第二次IO请求；</p><p>AIO的第二个优点是可以将多次IO合并成一次IO，如果InnoDB存储引擎判断多次IO的读取之间是连续的，则会一次读取出所有的数据，来提高读取的效率。</p><h3 id="刷新邻接页" tabindex="-1"><a class="header-anchor" href="#刷新邻接页"><span>刷新邻接页</span></a></h3><p>刷新邻接页的目的是为了提交脏页的刷新效率。</p><p>在刷新一个脏页的时候，会同步扫描这个脏页所在的区的其他的也，如果发现有脏页，则会一起进行刷新。</p><p>脏页的刷新频率太快，就会导致一个脏页被刷新后马上又变成了脏页，因此在InnoDB 1.2.x版本之后支持关闭该特性。</p><blockquote><p>对于传统机械硬盘建议开启该特性；对于固态硬盘建议关闭此特性；</p></blockquote><h1 id="文件" tabindex="-1"><a class="header-anchor" href="#文件"><span>文件</span></a></h1><h2 id="参数文件" tabindex="-1"><a class="header-anchor" href="#参数文件"><span>参数文件</span></a></h2><p>MySQL的参数文件就是MySQL的配置文件，用于设置MySQL运行时的一些参数。MySQL的启动不是必须配置文件的，它在编译的时候就为需要的参数设置了默认值。</p><h3 id="参数类型" tabindex="-1"><a class="header-anchor" href="#参数类型"><span>参数类型</span></a></h3><p>MySQL的参数分为：</p><ul><li>动态参数 —— 可以在MySQL运行期间进行修改；</li><li>静态参数 —— 在MySQL的整个实例周期内都不得进行更改；</li></ul><p>动态参数的修改使用<code>SET</code>命令，在动态参数中有些参数只在当前会话中生效，有些参数则可以在整个实例的生命周期中生效。<span alt="solid">对于动态参数的修改，会在MySQL重新启动后失效</span>。</p><h2 id="日志文件" tabindex="-1"><a class="header-anchor" href="#日志文件"><span>日志文件</span></a></h2><p>常见的日志文件有：错误日志、二进制日志、慢查询日志和查询日志。</p><h3 id="错误日志" tabindex="-1"><a class="header-anchor" href="#错误日志"><span>错误日志</span></a></h3><p>错误日志对MySQL的启动、运行和关闭过程进行了记录。可以使用如下命令找到错误日志的存储位置：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;log_error&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="慢查询日志" tabindex="-1"><a class="header-anchor" href="#慢查询日志"><span>慢查询日志</span></a></h3><p>慢查询日志记录运行时间大于某个阈值的所有SQL语句，这个阈值可以在MySQL启动的时候进行设置。<span alt="solid">默认情况下，MySQL不会记录慢查询日志，需要手动开启</span>，需要手动设置<code>log_slow_queries</code>参数设置为<code>ON</code>来开启慢查询日志。</p><p>在某些情况下如果需要记录哪些查询语句没有走索引，可以通过设置<code>log_queries_not_using_indexes</code>设置为<code>ON</code>来让慢查询日志记录下这些SQL。</p><h3 id="查询日志" tabindex="-1"><a class="header-anchor" href="#查询日志"><span>查询日志</span></a></h3><p>查询日志记录下所有对MySQL数据库请求的信息，无论是否得到了正确的执行，例如Access Denied的请求、执行出错的SQL语句等。</p><h3 id="二进制日志" tabindex="-1"><a class="header-anchor" href="#二进制日志"><span>二进制日志</span></a></h3><p>二进制日志文件记录了所有对MySQL数据库执行更改的操作，不包括Select和Show这类操作（<em>这类操作会被记录在查询日志中</em>）。需要注意的是<span alt="blue">执行更改并不意味着数据会发生变化</span>，只要你这个SQL语句是要执行更改操作的都会被记录在二进制日志文件中。</p><p><strong>二进制日志的主要作用：</strong></p><ul><li>恢复 —— 某些数据的恢复需要二进制日志，例如在一个数据库的全备文件恢复后，可以通过二进制日志将其恢复到某个时间点；</li><li>复制 —— 常见的应用就是MySQL的主从复制；</li><li>审计 —— 可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击；</li></ul><p>二进制日志文件在默认情况下并没有启动，需要手动指定参数来启动。与查询日志和错误日志不同，二进制文件的格式为二进制，查看的时候必须使用mysqlbinlog工具来查看。</p><h2 id="套接字文件" tabindex="-1"><a class="header-anchor" href="#套接字文件"><span>套接字文件</span></a></h2><p>在Unix系统下本地连接MySQL可以采用Unix域套接字方式，所以需要一个套接字文件，通常为<code>/tmp/mysql.sock</code>文件。</p><h2 id="pid文件" tabindex="-1"><a class="header-anchor" href="#pid文件"><span>Pid文件</span></a></h2><p>Pid文件用于记录MySQL实例运行时的进程号，默认位于数据库目录下。</p><h2 id="表结构定义文件" tabindex="-1"><a class="header-anchor" href="#表结构定义文件"><span>表结构定义文件</span></a></h2><p>表结构文件是一个以<code>.frm</code>为后缀的文件，它用于记录该表的表结构定义，该文件为文本类型，可以直接使用<code>cat</code>、<code>tail</code>等命令直接查看。</p><h2 id="innodb存储引擎文件" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎文件"><span>InnoDB存储引擎文件</span></a></h2><h3 id="表空间文件" tabindex="-1"><a class="header-anchor" href="#表空间文件"><span>表空间文件</span></a></h3><p>表空间文件分为：共享表空间和独立表空间。</p><ul><li>共享表空间 —— 所有基于InnoDB存储引擎的表的数据都会记录到共享表空间；</li><li>独立表空间 —— 每个基于InnoDB存储引擎的表都会产生一个独立的表空间来记录数据；</li></ul><p>在设置了<code>innodb_data_file_path</code>参数后，所有基于InnoDB存储引擎的表的数据都会存储在指定的路径下的表空间中。如果设置了<code>innodb_file_per_table</code>参数，则会为每个基于InnoDB存储引擎的表创建一个独立的表空间。</p><p><span alt="solid">独立表空间不会存储该表的所有信息，仅存储该表的数据、索引和Insert Buffer Bitmap等信息</span>，其余的信息还是存储在共享表空间中。</p><h3 id="重做日志文件" tabindex="-1"><a class="header-anchor" href="#重做日志文件"><span>重做日志文件</span></a></h3><p>重做日志文件（redo log）记录了InnoDB存储引擎的事务日志。redo log保证了数据库宕机后能恢复到宕机前的状态。</p><p>每个InnoDB的存储引擎至少有1个重做日志文件组，每个文件组下至少有2个重做日志，例如默认的idb_logfile0和idb_logfile1。<span alt="solid">InnoDB的redo log采用循环写的方式运行</span>，当重做日志文件1被写满时会切换到重做日志2，同理当重做日志2写满时会切换到重做日志1。</p><blockquote><p><span alt="red">重做日志文件（redo log）与二进制日志（bin log）之间的区别？</span></p><p>1️⃣二进制日志记录了所有与MySQL数据库有关的日志记录，包括了InnoDB、MyISAM、Heap等其他存储引擎的日志；重做日志文件只记录与InnoDB存储引擎有关的事务日志。</p><p>2️⃣二进制日志是记录了一个事务的具体操作，是逻辑日志；重做日志记录是对于每个页更改的物理情况；</p><p>3️⃣二进制日志文件是在事务提交前记录的，只写磁盘一次；而在事务执行的过程中会不断的有重做日志被写入到重做日志文件中；</p></blockquote><p>写入重做日志并不是直接写，而是先写入到redo log buffer中，然后按照一定的条件顺序地写入日志文件。redo log buffer中的内容会按照512个字节（<em>一个扇区</em>）的顺序写入到磁盘，它是必定成功的，所以是不需要doublewrite机制来保证的。</p><p>将重做日志缓冲的写入磁盘的时机除了Master Thread以每秒或者每十秒的频率外，还可以通过<code>innodb_flush_log_at_rtx_commit</code>控制。该参数表示了在事务提交时对于重做日志的处理方式，可选值有：</p><ul><li>0 —— 提交事务时，不将事务的重做日志写入磁盘上的日志文件，等待主线程每秒的刷新，无法保证事务的持久性，会造成部分的事务日志丢失。</li><li>1 —— 在执行commit时，以同步的方式将重做日志缓冲写入到磁盘中，<span alt="blue">可以保证事务的持久性</span>。</li><li>2 —— 在执行commit时，以异步的方式将重做日志缓冲写入到磁盘中，不可以保证事务的持久性。但是在MySQL实例宕机而操作系统没有宕机的条件下，可以保证事务的持久性。因为事务日志会被保存在文件系统的缓存中，只要MySQL的实力恢复，仍然可以保证事务的持久性。</li></ul><h1 id="表" tabindex="-1"><a class="header-anchor" href="#表"><span>表</span></a></h1>`,119))])}const f=d(c,[["render",h]]),y=JSON.parse('{"path":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html","title":"MySQL体系结构和存储引擎","lang":"zh-CN","frontmatter":{"date":"2025-05-10T00:00:00.000Z","category":["数据库"],"tag":["MySQL"],"archive":false},"headers":[{"level":2,"title":"MySQL体系结构","slug":"mysql体系结构","link":"#mysql体系结构","children":[]},{"level":2,"title":"MySQL的存储引擎","slug":"mysql的存储引擎","link":"#mysql的存储引擎","children":[{"level":3,"title":"InnoDB与MySIAM之间的区别","slug":"innodb与mysiam之间的区别","link":"#innodb与mysiam之间的区别","children":[]}]},{"level":2,"title":"InnoDB存储引擎体系结构","slug":"innodb存储引擎体系结构","link":"#innodb存储引擎体系结构","children":[{"level":3,"title":"后台线程","slug":"后台线程","link":"#后台线程","children":[]},{"level":3,"title":"内存","slug":"内存","link":"#内存","children":[]}]},{"level":2,"title":"CheckPoint技术","slug":"checkpoint技术","link":"#checkpoint技术","children":[{"level":3,"title":"InnoDB中CheckPoint触发","slug":"innodb中checkpoint触发","link":"#innodb中checkpoint触发","children":[]}]},{"level":2,"title":"InnoDB的关键特性","slug":"innodb的关键特性","link":"#innodb的关键特性","children":[{"level":3,"title":"插入缓冲","slug":"插入缓冲","link":"#插入缓冲","children":[]},{"level":3,"title":"两次写","slug":"两次写","link":"#两次写","children":[]},{"level":3,"title":"自适应Hash索引","slug":"自适应hash索引","link":"#自适应hash索引","children":[]},{"level":3,"title":"异步IO","slug":"异步io","link":"#异步io","children":[]},{"level":3,"title":"刷新邻接页","slug":"刷新邻接页","link":"#刷新邻接页","children":[]}]},{"level":2,"title":"参数文件","slug":"参数文件","link":"#参数文件","children":[{"level":3,"title":"参数类型","slug":"参数类型","link":"#参数类型","children":[]}]},{"level":2,"title":"日志文件","slug":"日志文件","link":"#日志文件","children":[{"level":3,"title":"错误日志","slug":"错误日志","link":"#错误日志","children":[]},{"level":3,"title":"慢查询日志","slug":"慢查询日志","link":"#慢查询日志","children":[]},{"level":3,"title":"查询日志","slug":"查询日志","link":"#查询日志","children":[]},{"level":3,"title":"二进制日志","slug":"二进制日志","link":"#二进制日志","children":[]}]},{"level":2,"title":"套接字文件","slug":"套接字文件","link":"#套接字文件","children":[]},{"level":2,"title":"Pid文件","slug":"pid文件","link":"#pid文件","children":[]},{"level":2,"title":"表结构定义文件","slug":"表结构定义文件","link":"#表结构定义文件","children":[]},{"level":2,"title":"InnoDB存储引擎文件","slug":"innodb存储引擎文件","link":"#innodb存储引擎文件","children":[{"level":3,"title":"表空间文件","slug":"表空间文件","link":"#表空间文件","children":[]},{"level":3,"title":"重做日志文件","slug":"重做日志文件","link":"#重做日志文件","children":[]}]}],"git":{},"filePathRelative":"posts/数据库/MySQL体系结构和存储引擎.md","excerpt":"\\n<h2>MySQL体系结构</h2>\\n<p>数据库是由一个一个的文件组成的，而对实际的数据进行增删改查的操作则需要数据库实例来完成。</p>\\n"}');export{f as comp,y as data};
