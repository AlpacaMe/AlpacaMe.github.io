import{_ as i,c as d,a as e,b as l,d as t,e as s,w as p,r,o}from"./app-CN1440Oy.js";const c={};function h(u,n){const a=r("font");return o(),d("div",null,[n[6]||(n[6]=e('<h1 id="mysql体系结构和存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql体系结构和存储引擎"><span>MySQL体系结构和存储引擎</span></a></h1><h2 id="mysql体系结构" tabindex="-1"><a class="header-anchor" href="#mysql体系结构"><span>MySQL体系结构</span></a></h2><p>数据库是由一个一个的文件组成的，而对实际的数据进行增删改查的操作则需要数据库实例来完成。</p><p>MySQL数据库体系结构图如下所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/387a91fd2b85b6085445060ddf61ce96.png" alt=""></p>',5)),l("p",null,[n[1]||(n[1]=s("⭐MySQL的数据库的存储引擎是插件式的，每个存储引擎的开发者都可以按照它的标准去实现自定义的存储引擎。值得注意的是：")),t(a,{title:"red"},{default:p(()=>n[0]||(n[0]=[s("存储引擎是基于表的，而不是基于数据库的")])),_:1}),n[2]||(n[2]=s("。"))]),n[7]||(n[7]=e(`<blockquote><p>MySQL可以使用内部查询缓存（Caches）来查看是否可以直接提供结果，但随着并发性的增加，查询缓存成为了瓶颈。从MySQL 5.7.20版本开始，查询缓存已经被标注为废弃的特性，并且在8.0版本中被完全移除。</p></blockquote><h2 id="mysql的存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql的存储引擎"><span>MySQL的存储引擎</span></a></h2><p>MySQL的存储引擎分为官方的存储引擎的和第三方的存储引擎，其中InnoDB一开始就是第三方存储引擎，后被Oracle收购了。</p><p>其中常见的存储引擎比较如下表所示：</p><table><thead><tr><th>特点</th><th>MyISAM</th><th>Memory</th><th>InnoDB</th><th>Archive</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td></td><td>是</td><td>64TB</td><td></td><td>是</td></tr><tr><td>支持事务</td><td></td><td></td><td>是</td><td></td><td>是</td></tr><tr><td>锁粒度</td><td>表锁</td><td>表锁</td><td>行锁</td><td>行锁</td><td>行锁</td></tr><tr><td>MVCC/快照读</td><td></td><td></td><td>是</td><td>是</td><td>是</td></tr><tr><td>地理数据类型</td><td>是</td><td></td><td></td><td></td><td></td></tr><tr><td>B-Tree索引</td><td>是</td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>Hash索引</td><td></td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>全文索引</td><td>是</td><td></td><td></td><td></td><td></td></tr><tr><td>聚集索引</td><td></td><td></td><td>是</td><td></td><td></td></tr><tr><td>数据加密</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>数据缓存</td><td></td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>索引缓存</td><td></td><td>是</td><td>是</td><td></td><td>是</td></tr><tr><td>数据压缩</td><td>是</td><td></td><td></td><td>是</td><td></td></tr><tr><td>存储消耗</td><td>低</td><td>N/A</td><td>高</td><td>非常低</td><td>低</td></tr><tr><td>批量插入速度</td><td>高</td><td>高</td><td>低</td><td>非常高</td><td>高</td></tr><tr><td>集群数据库</td><td></td><td></td><td></td><td></td><td>是</td></tr><tr><td>支持复制</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>外键支持</td><td></td><td></td><td>是</td><td></td><td></td></tr><tr><td>备份/恢复</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>查询缓存</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h3 id="innodb与mysiam之间的区别" tabindex="-1"><a class="header-anchor" href="#innodb与mysiam之间的区别"><span>InnoDB与MySIAM之间的区别</span></a></h3><p>⭐事务支持</p><ul><li><p>InnoDB</p><p>1️⃣完全支持ACID事务（<em>原子性、一致性、隔离性和持久性</em>）；</p><p>2️⃣支持四种隔离级别（<em>读未提交、读已提交、可重复读和序列化</em>），默认隔离级别可重复读。</p><p>3️⃣支持事务回滚和崩溃恢复；</p></li><li><p>MyISAM</p><p>1️⃣不支持事务；</p><p>2️⃣所有操作都是自动提交；</p><p>3️⃣不适合需要事务处理的业务场景；</p></li></ul><p>⭐锁支持</p><ul><li><p>InnoDB</p><p>1️⃣行级锁（<em>某些情况下会升级为表锁</em>）；</p><p>2️⃣支持意向锁（<em>共享锁和排他锁</em>）；</p><p>3️⃣并发性能姮好，适合高并发读写场景；</p><p>4️⃣锁粒度更细，可以减少锁冲突；</p></li><li><p>MyISAM</p><p>1️⃣表级锁（读锁和写锁）；</p><p>2️⃣写操作会阻塞所有的读操作和写操作；</p><p>3️⃣读操作之间不阻塞，但会阻塞写操作；</p><p>4️⃣并发性能较差，适合读多写少的场景；</p></li></ul><p>⭐数据完成性</p><ul><li><p>InnoDB</p><p>1️⃣支持外键约束；</p><p>2️⃣自动维护参照完整性；</p><p>3️⃣支持级联操作（ON DELETE/UPDATE CASCADE等）；</p></li><li><p>MyISAM</p><p>1️⃣不支持外键；</p><p>2️⃣没有参照完整性检查；</p><p>3️⃣需要应用层自行维护数据关系；</p></li></ul><p>⭐存储结构</p><ul><li><p>InnoDB</p><p>1️⃣数据和索引存储在同一个文件中（<code>.idb</code>文件）；</p><p>2️⃣使用聚簇索引，主键索引的叶子节点存储数据行；</p><p>3️⃣支持自适应Hash索引；</p><p>4️⃣支持崩溃恢复机制；</p></li><li><p>MyISAM</p><p>1️⃣数据和索引分开存储（<code>.myd</code>存储数据，<code>.myi</code>存储索引）；</p><p>2️⃣使用非聚簇索引，索引叶子节点存储数据行的指针；</p><p>3️⃣不支持崩溃恢复（需要手动修复）；</p></li></ul><p>⭐性能特点</p><ul><li>InnoDB —— 写入性能较好，适合频繁更新的场景。随着数据量增大，性能下降较慢。需要更多的内存来作为缓冲池。</li><li>MyISAM —— 读取性能较好，适合多读少写的场景。随着数据增大，性能下降较快。内存占用相对较少。</li></ul><p>⭐备份与恢复</p><ul><li>InnoDB —— 支持热备份、增量备份，恢复机制完善；</li><li>MyISAM —— 备份时需要锁定表，不支持热备份，恢复比较麻烦；</li></ul><p>⭐其它特性</p><ul><li>InnoDB —— 支持全文索引、支持压缩表、支持空间索引、表空间可以管理；</li><li>MyISAM —— 原生支持全文索引，不支持压缩表，不支持GIS数据，表空间固定；</li></ul><h1 id="innodb存储引擎" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎"><span>InnoDB存储引擎</span></a></h1><h2 id="innodb存储引擎体系结构" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎体系结构"><span>InnoDB存储引擎体系结构</span></a></h2><p>后台线程的作用：负责刷新内存池中的数据。主要包含将最新的数据加载到内存中和将最近修改的数据刷新到磁盘上。</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250505180902737.png" alt="image-20250505180902737"></p><h3 id="后台线程" tabindex="-1"><a class="header-anchor" href="#后台线程"><span>后台线程</span></a></h3><p>InnoDB存储引擎后台是多线程的模型，所以在它的后台不同的线程负责不同的任务。</p><ul><li><p>Master Thread</p><p>主要负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性，它包括了：脏页的刷新、合并插入缓冲以及UNDO页的回收等。</p></li><li><p>IO Thread</p><p>主要使用AIO来处理IO请求，IO Thread主要负责此类IO请求的回调。</p></li><li><p>Purge Thread</p><p>主要负责在事务提交后来回收已经使用并分配的undo页。</p></li></ul><p>在InnoDB的1.0版本中，purge操作由Master Thread来完成，而在1.1版本之后，purge可以由独立的线程来完成，以此来降低Master Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。可以使用如下的配置来开启Purge Thread。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span></span>
<span class="line">innodb_purge_thread<span class="token operator">=</span><span class="token number">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="内存" tabindex="-1"><a class="header-anchor" href="#内存"><span>内存</span></a></h3><h4 id="缓冲池" tabindex="-1"><a class="header-anchor" href="#缓冲池"><span>缓冲池</span></a></h4><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。</p><ul><li><p>读操作</p><p>在读取数据库中的数据时，通常也是以页为单位来读取的。每次读取的时候会先查看缓冲池中是否存在当前页，如果存在就直接返回；反之，则从磁盘中读取对应的数据。</p></li><li><p>写操作</p><p>在修改数据库中的数据时，不会去直接修改磁盘上的数据，而是先修改缓冲池中对应页的数据，然后再按照一定频率将缓冲池中的数据刷新到磁盘上。</p></li></ul><p>⭐<strong>缓冲池中的数据类型</strong></p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250506211444333.png" alt="image-20250506211444333"></p><p>InnoDB的缓冲池中，<span alt="solid">数据页和索引页占据了大部分的内存空间</span>。除此之外还有：插入缓冲、自适应Hash索引、锁信息和数据字典信息等。</p><blockquote><p>从InnoDB 1.x版本开始支持有多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例中。</p></blockquote><p>⭐<strong>缓冲池中的数据管理方案</strong></p>`,38)),t(a,{title:"gray"},{default:p(()=>n[3]||(n[3]=[s("LRU（Latest Recent Used，最近最少使用）算法")])),_:1}),n[8]||(n[8]=e('<p>InnoDB中并没有采用朴素的LRU算法，而是设置了midpoint（中点位），在默认情况下midpoint设置为列表长度的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>5</mn></mrow><mrow><mn>8</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\\frac{5}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">8</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">5</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>的位置。在InnoDB中midpoint之前的列表称之为new列表（<em>简单理解为热点数据</em>），之后的列表则称之为old列表。</p><p>与朴素LRU算法的区别：</p><ol><li>每次新被读取的页并不会放置到列表的首个位置，而是放置在midpoint位置；</li><li>处于midpoint位置的页会在一个固定的时间后加入到LRU队列的new列表中；</li></ol><p>这样的改进是为了<span alt="solid">避免某些索引或者数据的扫描操作将热点数据刷出了LRU列表</span>，例如在某一次查询中需要加载大量的页到缓冲池中，但是仅仅只在这一次查询中生效，如果直接放到LRU列表的首个位置，则会导致真正的热点数据被刷出了LRU列表。</p>',4)),t(a,{title:"gray"},{default:p(()=>n[4]||(n[4]=[s("Free List")])),_:1}),n[9]||(n[9]=l("p",null,"在InnoDB存储引擎中首次加载的时候LRU列表是空的，此时页都存放在Free List中。当需要从缓冲池中需要新增一个页的时候，首先在Free List中找是否有可用的空闲页，如果有则将该页从Free List中删除，将其加入到LRU列表中；如果没有，则根据LRU列表的淘汰策略，将LRU列表末尾的页分配给新的页。",-1)),t(a,{title:"gray"},{default:p(()=>n[5]||(n[5]=[s("Flush List")])),_:1}),n[10]||(n[10]=e(`<p>当LRU列表中的页被修改时，则称该页为“脏页”（<em>缓冲池中的数据与磁盘上的数据不一致</em>），脏页不仅在LRU列表中，也存在于Flush List中。数据库会通过CheckPoint机制将Flus List中的数据刷新到磁盘上。</p><blockquote><p>LRU列表用来管理缓冲池中页的可用性，Flus List用于记录与磁盘上数据不一致的页。两个列表中都有脏页，是不互相冲突的。</p></blockquote><h4 id="重做日志缓冲" tabindex="-1"><a class="header-anchor" href="#重做日志缓冲"><span>重做日志缓冲</span></a></h4><p>InnoDB存储引擎首先将重做日志信息放入到这个缓冲区，然后再按照一定的频率将其刷新到重做日志文件中。除了按照一定的频率外，还有三种情况也会触发将日志缓冲刷新到文件中：</p><ol><li>Master Thread 每秒将重做日志缓冲刷新到重做日志文件中；</li><li>每个事务提交时会将重做日志缓冲刷新到重做日志文件中；</li><li>当重做日志缓冲池剩余空间不足50%的时候，重做日志缓冲会被刷新到重做日志文件中；</li></ol><h4 id="额外内存池" tabindex="-1"><a class="header-anchor" href="#额外内存池"><span>额外内存池</span></a></h4><p>额外的内存池主要是记录一些数据结构本身的信息，例如缓冲池的帧缓冲和对应的缓冲控制对象等。当需要申请很大的InnoDB缓冲池时，也需要相应的考虑扩大额外内存池的大小。</p><h2 id="checkpoint技术" tabindex="-1"><a class="header-anchor" href="#checkpoint技术"><span>CheckPoint技术</span></a></h2><p>为了提高数据库的性能和稳定性，缓冲池避免了频繁对磁盘进行读取或写入操作，但并不能保证数据库在宕机之后能够恢复。</p><p>目前的事务型数据库，都采取了Write Ahead Log，即当事务提交时，先写重做日志，再修改页中的数据。此时如果宕机了，可以通过重做日志来恢复数据。</p><p>在实际的条件下，缓冲池并不能无限大，重做日志也无法无限大，所以将数据缓冲和日志缓冲刷新到磁盘中是必须要执行的操作。</p><p><span alt="solid">CheckPoint就是用来保障将数据缓存和日志缓存正确的刷新到磁盘上的一项技术</span>。</p><p><strong>它主要用来解决下面的是三个问题：</strong></p><p>1️⃣缩短数据库的恢复时间；</p><p>2️⃣缓冲池不够用的时候，将脏页刷新到磁盘。</p><p>通过LRU算法的淘汰策略，选出需要被淘汰的页。如果当前页为脏页，则会被强制执行CheckPoint，即将脏页中的数据刷新到磁盘上。</p><p>3️⃣重做日志不可用的时候，刷新脏页；</p><p>当重做日志不可用的时候，依赖这些重做日志无法完全恢复数据，则会强制执行CheckPoint，将脏页中的数据刷新到磁盘上来防止数据库宕机后，缓冲池中的数据与磁盘上的数据不一致的情况。</p><blockquote><p>重做日志不可用可能发生的情况：</p><ol><li>日志损坏：因为硬件故障、磁盘错误或软件Bug，导致无法读取或者解析；</li><li>日志空间耗尽：因为系统异常导致重做日志无法正常循环，导致日志文件不断增大；</li><li>数据不一致：在数据库的恢复过程中发现重做日志中与数据文件不一致，即使用重做日志无法恢复数据。</li></ol></blockquote><h3 id="innodb中checkpoint触发" tabindex="-1"><a class="header-anchor" href="#innodb中checkpoint触发"><span>InnoDB中CheckPoint触发</span></a></h3><p>首先说到在InnoDB中存在两种CheckPoint：</p><ol><li>Sharp CheckPoint —— 将所有的脏页都刷新到磁盘中；</li><li>Fuzzy CheckPoint —— 将部分的脏页刷新到磁盘中；</li></ol><p>其中第一个Sharp CheckPoint发生在数据库关闭的时候，第二个Fuzzy CheckPoint则发生在数据库运行时。</p><p>InnoDB中发生Fuzzy CheckPoint有以下几种情况：</p><ul><li><p>Master Thread CheckPoint</p><p>Master Thread按照固定的频率将缓冲池中一定比例的脏页刷新到磁盘上。</p></li><li><p>FLUSH_LRU_LIST CheckPoint</p><p>为了保证LRU列表中有100个空闲页可用，会根据LRU列表的淘汰策略选择需要被淘汰的页，如果该页为脏页，就会被强制刷新磁盘上。</p></li><li><p>Async/Sync Flush CheckPoint</p><p>当日志不可用时，会从Flush List中选择一部分的脏页刷新到磁盘上。至于采用Async的方式刷新，还是采用Sync的方式刷新，则根据CheckPoint的LSN(<em>页版本号</em>)和重做日志的LSN来决定。</p></li><li><p>Dirty Page too much CheckPoint</p><p>当缓冲池中脏页的比例太多的时候，也会被强制执行CheckPoint技术。</p></li></ul><h2 id="innodb的关键特性" tabindex="-1"><a class="header-anchor" href="#innodb的关键特性"><span>InnoDB的关键特性</span></a></h2><h3 id="插入缓冲" tabindex="-1"><a class="header-anchor" href="#插入缓冲"><span>插入缓冲</span></a></h3><p>Insert Buffer的出现主要是为了解决：<span alt="solid">提高非聚集索引插入的性能</span>。</p><p>对于非聚集索引的插入或更新操作，先判断要插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率或在特定的情况下将Insert Buffer和辅助索引的叶子节点进行合并操作（<em>可以将多个插入操作合并为一个插入操作</em>）。</p><p>使用Insert Buffer需要满足两个条件：</p><p>🅰️索引是辅助索引；</p><p>🅱️索引不能是唯一的；</p><blockquote><p>为什么索引不能是唯一的？</p><p>如果索引是唯一的，此时插入一条数据，数据库需要去查找索引页来判断数据的唯一性。在查找索引的过程中肯定又会发生离散读取的情况，也就导致了Insert Buffer失去了意义。</p></blockquote><p><span alt="solid">Insert Buffer的数据结构是一颗B+树</span>，因此也是由叶子节点和非叶子节点组成。</p><p>⭐非叶子节点</p><p>非叶子节点存放的是查询的Search Key，由三部分组成：space、marker和offset。</p><ul><li>space —— 表示待插入记录所在表空间的id，占据4个字节；</li><li>marker —— 兼容老版本的Insert Buffer，占据1个字节；</li><li>offset —— 表示页所在的偏移量，占据4个字节；</li></ul><p>⭐叶子节点</p><p>当一个辅助索引需要插入到页时，如果这个页不在缓冲池中，那么首先会构造一个Search key，然后查询Insert Buffer这棵树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。</p><p>叶子节点也有三部分组成：Search Key（<em>包含space、marker和offer</em>）、metadata和记录的相关信息。</p><p>其中Search Key的含义与非叶子节点中Search Key的含义相同，metadata用来标识每个记录进入Insert Buffer的顺序。</p><h4 id="merge-insert-buffer" tabindex="-1"><a class="header-anchor" href="#merge-insert-buffer"><span>Merge Insert Buffer</span></a></h4><p>Merge Insert Buffer是指将Insert Buffer中的数据合并到真正的索引页中，在合并的时候可能出现以下的情况：</p><p>1️⃣辅助索引页被读取到缓冲池中</p><p>在执行一些常规的查询操作时，我们可能需要将原本不在缓冲池中的索引页读取到缓冲池中，此时会通过Insert Buffer Bitmap来判断当前索引页是否在Insert Buffer B+树中存在未合并的数据，若是，则将数据合并到该索引页中。</p><blockquote><p>Insert Buffer Bitmap 是用来追踪每个辅助索引页的可用空间的。</p></blockquote><p>2️⃣Insert Buffer Bitmap 页追踪到该辅助索引页已无可用空间</p><p>Insert Buffer Bitmap 在追踪每个辅助索引页的时候，如果发现某个辅助索引页的可用空间小于了1/32页，则会强制读取辅助索引页，将Insert Buffer B+树中该页的记录以及待插入的记录插入到该辅助索引页中。</p><p>3️⃣Master Thread</p><p>Master Thread线程中每秒或者每十秒都会进行一次Merge Insert Buffer的操作，二者的差距在于merge页的数量不同。</p><h3 id="两次写" tabindex="-1"><a class="header-anchor" href="#两次写"><span>两次写</span></a></h3><p>两次写的目的是为了提高数据的可靠性。在InnoDB存储引擎中，doublewrite的体系架构图如下：</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250507230657563.png" alt="image-20250507230657563"></p><p>doublewrite由两部分组成：内存中的doublewrite buffer和磁盘上共享表空间中连续的128个页（<em>2个区，2MB</em>）。</p><p>当需要将缓冲池中的脏页刷新到磁盘上时，并不是直接将数据写入磁盘的。</p><p>1️⃣首先将数据脏页复制到内存中的doublewrite buffer中；</p><p>2️⃣doublewrite buffer分两次，每次按照1MB的顺序将数据写入到共享表空间的物理磁盘中；</p><p>3️⃣doublewrite buffer将数据同步到磁盘上；</p><p>如果在将某个页写入到表中的时只写入了一部分，数据库就发生了宕机，在没有doublewrite的情况下， 这个页就部分失效了；反之，在有doublewrite的情况下，可以利用共享表空间的doublewrite来回复这个页。</p><p>简而言之，两次写在共享表空间中创建一个备份，在主数据发生损坏的时候，可以通过共享表空间中的备份来恢复数据。</p><h3 id="自适应hash索引" tabindex="-1"><a class="header-anchor" href="#自适应hash索引"><span>自适应Hash索引</span></a></h3><p>InnoDB存储引擎会监控各个索引页的查询，如果建立hash索引可以带来速度提升，则建立hash索引，称之为自适应hash索引。</p><p>InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点数据建立哈希索引，其中要求每次访问的模式必须是一样的（<em>意思就是查询条件是一样的</em>）。</p><p>例如对于联合索引<code>(a,b)</code>而言，我们通过下面两种方式去访问：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">where</span> a <span class="token operator">=</span> xxx<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">where</span> a<span class="token operator">=</span> xxx <span class="token operator">and</span> b<span class="token operator">=</span>xxx<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果每次的查询是上述两种交替出现，InnoDB存储引擎则不会为这个索引页创建AHI（Adaptive Hash Index，自适应Hash索引）。</p><p>对于同一个访问模式而言，它还需要满足下面的条件：</p><ul><li>以该模式访问了100次；</li><li>页通过该模式访问了N次，其中N 为页中数据总量的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>1</mn><mn>6</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\\frac{1}{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>；</li></ul><h3 id="异步io" tabindex="-1"><a class="header-anchor" href="#异步io"><span>异步IO</span></a></h3><p>为了提高磁盘的操作性能，InnoDB存储引擎采用的AIO的方式对磁盘进行读写。</p><p>AIO的第一个优点就是它是非阻塞的，可以在发出一次IO请求后再次发出第二次IO请求；</p><p>AIO的第二个优点是可以将多次IO合并成一次IO，如果InnoDB存储引擎判断多次IO的读取之间是连续的，则会一次读取出所有的数据，来提高读取的效率。</p><h3 id="刷新邻接页" tabindex="-1"><a class="header-anchor" href="#刷新邻接页"><span>刷新邻接页</span></a></h3><p>刷新邻接页的目的是为了提交脏页的刷新效率。</p><p>在刷新一个脏页的时候，会同步扫描这个脏页所在的区的其他的也，如果发现有脏页，则会一起进行刷新。</p><p>脏页的刷新频率太快，就会导致一个脏页被刷新后马上又变成了脏页，因此在InnoDB 1.2.x版本之后支持关闭该特性。</p><blockquote><p>对于传统机械硬盘建议开启该特性；对于固态硬盘建议关闭此特性；</p></blockquote><h1 id="文件" tabindex="-1"><a class="header-anchor" href="#文件"><span>文件</span></a></h1><h2 id="参数文件" tabindex="-1"><a class="header-anchor" href="#参数文件"><span>参数文件</span></a></h2><p>MySQL的参数文件就是MySQL的配置文件，用于设置MySQL运行时的一些参数。MySQL的启动不是必须配置文件的，它在编译的时候就为需要的参数设置了默认值。</p><h3 id="参数类型" tabindex="-1"><a class="header-anchor" href="#参数类型"><span>参数类型</span></a></h3><p>MySQL的参数分为：</p><ul><li>动态参数 —— 可以在MySQL运行期间进行修改；</li><li>静态参数 —— 在MySQL的整个实例周期内都不得进行更改；</li></ul><p>动态参数的修改使用<code>SET</code>命令，在动态参数中有些参数只在当前会话中生效，有些参数则可以在整个实例的生命周期中生效。<span alt="solid">对于动态参数的修改，会在MySQL重新启动后失效</span>。</p><h2 id="日志文件" tabindex="-1"><a class="header-anchor" href="#日志文件"><span>日志文件</span></a></h2><p>常见的日志文件有：错误日志、二进制日志、慢查询日志和查询日志。</p><h3 id="错误日志" tabindex="-1"><a class="header-anchor" href="#错误日志"><span>错误日志</span></a></h3><p>错误日志对MySQL的启动、运行和关闭过程进行了记录。可以使用如下命令找到错误日志的存储位置：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;log_error&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="慢查询日志" tabindex="-1"><a class="header-anchor" href="#慢查询日志"><span>慢查询日志</span></a></h3><p>慢查询日志记录运行时间大于某个阈值的所有SQL语句，这个阈值可以在MySQL启动的时候进行设置。<span alt="solid">默认情况下，MySQL不会记录慢查询日志，需要手动开启</span>，需要手动设置<code>log_slow_queries</code>参数设置为<code>ON</code>来开启慢查询日志。</p><p>在某些情况下如果需要记录哪些查询语句没有走索引，可以通过设置<code>log_queries_not_using_indexes</code>设置为<code>ON</code>来让慢查询日志记录下这些SQL。</p><h3 id="查询日志" tabindex="-1"><a class="header-anchor" href="#查询日志"><span>查询日志</span></a></h3><p>查询日志记录下所有对MySQL数据库请求的信息，无论是否得到了正确的执行，例如Access Denied的请求、执行出错的SQL语句等。</p><h3 id="二进制日志" tabindex="-1"><a class="header-anchor" href="#二进制日志"><span>二进制日志</span></a></h3><p>二进制日志文件记录了所有对MySQL数据库执行更改的操作，不包括Select和Show这类操作（<em>这类操作会被记录在查询日志中</em>）。需要注意的是<span alt="blue">执行更改并不意味着数据会发生变化</span>，只要你这个SQL语句是要执行更改操作的都会被记录在二进制日志文件中。</p><p><strong>二进制日志的主要作用：</strong></p><ul><li>恢复 —— 某些数据的恢复需要二进制日志，例如在一个数据库的全备文件恢复后，可以通过二进制日志将其恢复到某个时间点；</li><li>复制 —— 常见的应用就是MySQL的主从复制；</li><li>审计 —— 可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击；</li></ul><p>二进制日志文件在默认情况下并没有启动，需要手动指定参数来启动。与查询日志和错误日志不同，二进制文件的格式为二进制，查看的时候必须使用mysqlbinlog工具来查看。</p><h2 id="套接字文件" tabindex="-1"><a class="header-anchor" href="#套接字文件"><span>套接字文件</span></a></h2><p>在Unix系统下本地连接MySQL可以采用Unix域套接字方式，所以需要一个套接字文件，通常为<code>/tmp/mysql.sock</code>文件。</p><h2 id="pid文件" tabindex="-1"><a class="header-anchor" href="#pid文件"><span>Pid文件</span></a></h2><p>Pid文件用于记录MySQL实例运行时的进程号，默认位于数据库目录下。</p><h2 id="表结构定义文件" tabindex="-1"><a class="header-anchor" href="#表结构定义文件"><span>表结构定义文件</span></a></h2><p>表结构文件是一个以<code>.frm</code>为后缀的文件，它用于记录该表的表结构定义，该文件为文本类型，可以直接使用<code>cat</code>、<code>tail</code>等命令直接查看。</p><h2 id="innodb存储引擎文件" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎文件"><span>InnoDB存储引擎文件</span></a></h2><h3 id="表空间文件" tabindex="-1"><a class="header-anchor" href="#表空间文件"><span>表空间文件</span></a></h3><p>表空间文件分为：共享表空间和独立表空间。</p><ul><li>共享表空间 —— 所有基于InnoDB存储引擎的表的数据都会记录到共享表空间；</li><li>独立表空间 —— 每个基于InnoDB存储引擎的表都会产生一个独立的表空间来记录数据；</li></ul><p>在设置了<code>innodb_data_file_path</code>参数后，所有基于InnoDB存储引擎的表的数据都会存储在指定的路径下的表空间中。如果设置了<code>innodb_file_per_table</code>参数，则会为每个基于InnoDB存储引擎的表创建一个独立的表空间。</p><p><span alt="solid">独立表空间不会存储该表的所有信息，仅存储该表的数据、索引和Insert Buffer Bitmap等信息</span>，其余的信息还是存储在共享表空间中。</p><h3 id="重做日志文件" tabindex="-1"><a class="header-anchor" href="#重做日志文件"><span>重做日志文件</span></a></h3><p>重做日志文件（redo log）记录了InnoDB存储引擎的事务日志。redo log保证了数据库宕机后能恢复到宕机前的状态。</p><p>每个InnoDB的存储引擎至少有1个重做日志文件组，每个文件组下至少有2个重做日志，例如默认的idb_logfile0和idb_logfile1。<span alt="solid">InnoDB的redo log采用循环写的方式运行</span>，当重做日志文件1被写满时会切换到重做日志2，同理当重做日志2写满时会切换到重做日志1。</p><blockquote><p><span alt="red">重做日志文件（redo log）与二进制日志（bin log）之间的区别？</span></p><p>1️⃣二进制日志记录了所有与MySQL数据库有关的日志记录，包括了InnoDB、MyISAM、Heap等其他存储引擎的日志；重做日志文件只记录与InnoDB存储引擎有关的事务日志。</p><p>2️⃣二进制日志是记录了一个事务的具体操作，是逻辑日志；重做日志记录是对于每个页更改的物理情况；</p><p>3️⃣二进制日志文件是在事务提交前记录的，只写磁盘一次；而在事务执行的过程中会不断的有重做日志被写入到重做日志文件中；</p></blockquote><p>写入重做日志并不是直接写，而是先写入到redo log buffer中，然后按照一定的条件顺序地写入日志文件。redo log buffer中的内容会按照512个字节（<em>一个扇区</em>）的顺序写入到磁盘，它是必定成功的，所以是不需要doublewrite机制来保证的。</p><p>将重做日志缓冲的写入磁盘的时机除了Master Thread以每秒或者每十秒的频率外，还可以通过<code>innodb_flush_log_at_rtx_commit</code>控制。该参数表示了在事务提交时对于重做日志的处理方式，可选值有：</p><ul><li>0 —— 提交事务时，不将事务的重做日志写入磁盘上的日志文件，等待主线程每秒的刷新，无法保证事务的持久性，会造成部分的事务日志丢失。</li><li>1 —— 在执行commit时，以同步的方式将重做日志缓冲写入到磁盘中，<span alt="blue">可以保证事务的持久性</span>。</li><li>2 —— 在执行commit时，以异步的方式将重做日志缓冲写入到磁盘中，不可以保证事务的持久性。但是在MySQL实例宕机而操作系统没有宕机的条件下，可以保证事务的持久性。因为事务日志会被保存在文件系统的缓存中，只要MySQL的实力恢复，仍然可以保证事务的持久性。</li></ul><h1 id="表" tabindex="-1"><a class="header-anchor" href="#表"><span>表</span></a></h1><h2 id="索引组织表" tabindex="-1"><a class="header-anchor" href="#索引组织表"><span>索引组织表</span></a></h2><p>索引组织表是指按照主键顺序存储的表，InnoDB存储引擎的中的表都是索引组织表。索引组织表要求每张表都必须有一个主键，而对于没有显式指定主键的表：</p><ol><li>如果表有非空唯一索引，则使用该唯一索引作为主键；（<em>如果该表有多个非空唯一主键，则选择建表时定义的第一个非空唯一索引为主键，需要与列的顺序区分开</em>）。</li><li>如果表没有非空唯一索引，InnoDB自动创建一个6字节的指针作为该表的主键；</li></ol><h2 id="innodb的逻辑存储结构" tabindex="-1"><a class="header-anchor" href="#innodb的逻辑存储结构"><span>InnoDB的逻辑存储结构</span></a></h2><p>InnoDB存储引擎中所有数据都存储在表空间中，一个表空间由段、区和页（<em>也称为块</em>）组成。</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250512214259822.png" alt="image-20250512214259822"></p><h3 id="表空间" tabindex="-1"><a class="header-anchor" href="#表空间"><span>表空间</span></a></h3><p>InnoDB有两个表空间：共享表空间和独立表空间。</p><ul><li><p>共享表空间</p><p>所有基于InnoDB存储引擎的表都存储在共享表空间中；</p></li><li><p>独立表空间</p><p>启用 了<code>innodb_file_per_table</code>后会为每张表创建独立表空间来存放数据、索引和Insert Buffer Bitmap信息，其它的信息还是存储在共享表空间；</p></li></ul><blockquote><p>即使开启了独立表空间 ，共享表空间还是会在不断的增加；</p></blockquote><h4 id="段" tabindex="-1"><a class="header-anchor" href="#段"><span>段</span></a></h4><p>表空间是由各个段组成的，常见的段有：数据段、索引段和回滚段等。</p><p>因为InnoDB存储引擎是索引结构表，而且索引是B+树结构的，所以：</p><ul><li>数据段是B+树的叶子节点；</li><li>索引段是B+树的非叶子节点；</li></ul><h4 id="区" tabindex="-1"><a class="header-anchor" href="#区"><span>区</span></a></h4><p>区是由连续的页组成的空间，在任何情况下区的大小都是1MB。在默认情况下，InnoDB存储引擎中页大小为16KB，所以一个区中包含64个页。</p><blockquote><p>InnoDB 1.x版本引入了压缩页；InnDB 1.2.x版本引入了参数来配置默认页的大小；</p></blockquote><p>在开启了独立表空间的时候，建表的时候并不会一开始就去申请一个完整的页，而是先用32个页大小的碎片也来存放数据，在这些空间使用完毕后，采用一个区一个区的去申请存储空间。</p><h4 id="页" tabindex="-1"><a class="header-anchor" href="#页"><span>页</span></a></h4><p>页是InnoDB管理磁盘的最小单位，默认页的大小为16KB，常见的页有：</p><ul><li>B-Tree Node（数据页）</li><li>undo log page（undo页）</li><li>System page（系统页）</li><li>Transaction system page（事务数据页）</li><li>Insert Buffer Bitmap Page（插入缓冲位图页）</li><li>Insert Buffer Free List（插入缓冲空闲页）</li><li>Uncompressed Blob page（未压缩的二进制大对象页）</li><li>compressed Blob page（压缩的二进制大对象页）</li></ul><h4 id="行" tabindex="-1"><a class="header-anchor" href="#行"><span>行</span></a></h4><p>InnoDB存储引擎是面向列的，数据的是按照行进行存储的。每个页存放的记录遵循下面的计算公式：</p> \\frac{16KB}{2}−200=16×10242−200=7992 <p>也就是一个行最多可以存储7992行数据。</p><h2 id="innodb行记录格式" tabindex="-1"><a class="header-anchor" href="#innodb行记录格式"><span>InnoDB行记录格式</span></a></h2><p>在InnoDB 1.x版本之前提供了2中行格式来记录数据：Compact和Redundant，在MySQL5.1版本之后默认的行格式为：Compact。可以使用如下的命令来查看表的行格式：</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL"><pre><code><span class="line">show table status like ‘mytest%’;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="compact行记录格式" tabindex="-1"><a class="header-anchor" href="#compact行记录格式"><span>Compact行记录格式</span></a></h3><p>行记录的存储方式：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"> <span class="token comment">-------------------------------------------------------------</span></span>
<span class="line"><span class="token operator">|</span> 变长字段长度列表 <span class="token operator">|</span> <span class="token boolean">NULL</span>标志位 <span class="token operator">|</span> 记录头信息 <span class="token operator">|</span> 列<span class="token number">1</span>数据 <span class="token operator">|</span> 列<span class="token number">2</span>数据<span class="token operator">|</span> ··· <span class="token operator">|</span></span>
<span class="line"> <span class="token comment">-------------------------------------------------------------</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>变长字段长度列表</strong>**</p><p>Compact行记录格式的首部是一个非NULL变长字段长度列表 ，并且是按照列的顺序逆序放置的。</p><ul><li>如果列的长度小于255字节，则用1字节表示；</li><li>如果列的长度大于255字节，则用2字节表示；</li></ul><p><strong>NULL标志位</strong></p><p>Null标志为主要用来标记当前行数据中是否存在NULL值，用1个字节表示。</p><p><strong>记录头信息</strong></p><p>记录头信息固定为40个字节，记录的内容如下表所示：</p><table><thead><tr><th>名称</th><th>大小（bit）</th><th>描述</th></tr></thead><tbody><tr><td>( )</td><td>1</td><td>未知（保留空间）</td></tr><tr><td>( )</td><td>1</td><td>未知（保留空间）</td></tr><tr><td>deleted_flag</td><td>1</td><td>该行是否被删除</td></tr><tr><td>min_ree_falg</td><td>1</td><td>为1，如果该记录是预先被定义为最小的记录；</td></tr><tr><td>n_owned</td><td>4</td><td>该记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>索引堆中该记录的排序记录</td></tr><tr><td>record_type</td><td>3</td><td>记录类型，000表示普通，001表示B+树节点指针，010表示Infimum，011表示Supremum，1xx为保留含义</td></tr><tr><td>next_record</td><td>16</td><td>页中下一条记录的相对位置</td></tr></tbody></table><p><strong>列数据</strong></p><p>后面存储的就是每列的数据，需要额外注意<span alt="yellow">如果某一列的值为NULL值，它是不占据这部分的存储空间的</span>，也就是说NULL值只会占据NULL值标志位，而不会占据其他的存储空间。</p><p><strong>事务ID列和回滚指针</strong></p><p>除了用户定义的列以外，InnoDB存储引擎会为每个列创建两个隐藏的列，分别为事务ID列和回滚指针。</p><ul><li>事务ID列 —— 占据6个字节，用于表示该行数据是由哪个事务产生或者修改的；</li><li>回滚指针列 —— 占据7个字节，用于表示该行数据的上一版本以便在需要回滚事务的时候通过回滚指针可以快速找到对应的数据；</li></ul><p><strong>row_id列</strong></p><p>如果数据没有显式指定主键，表结构中也不存在非空的唯一索引列，InnoDB就会生成一个6个字节的row_id列作为该表的主键。</p><h3 id="行溢出数据" tabindex="-1"><a class="header-anchor" href="#行溢出数据"><span>行溢出数据</span></a></h3><p>InnoDB的存储引擎是索引结构表，即B+树结构的，这样每个页中至少要有两条记录，否则就变成了链表了，失去了B+树的意义。因此， 如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将数据页放到溢出页中。</p><p>对于溢出的数据，在原本的行数据中仅仅存储了部分的数据和溢出页的地址。</p><h3 id="dynamic行记录格式" tabindex="-1"><a class="header-anchor" href="#dynamic行记录格式"><span>Dynamic行记录格式</span></a></h3><p>InnoDB1.x版本之前同时支持Compact和Redundant格式称之为Antelope格式，在1.x版本之后继续推出新的文件格式同时支持Compressed和Dynamic格式；</p><p><strong>对于行溢出数据而言</strong></p><ul><li>在Compact和Redundant格式会存储溢出数据的前768个字节和溢出页的地址指针；</li><li>在Compressed和Dynamic格式中对于BLOB中的数据采用了完全行溢出的方式，在数据页中只存放20个字节的指针，指向溢出页的地址。</li></ul><p><strong>对于数据压缩而言</strong></p><ul><li>Compressed数据格式下TEXT、BLOB、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</li></ul><h3 id="char的行结构存储" tabindex="-1"><a class="header-anchor" href="#char的行结构存储"><span>CHAR的行结构存储</span></a></h3><p>对于CHAR与VARCHAR类型的理解，通常认为：</p><ul><li>VARCHAR存储变长长度字符串类型；</li><li>CAHR存储固定长度字符串类型；</li></ul><p>在MySQL 4.1版本之后CHAR(N)中的N不再标识字节长度而是标识字符长度，这就导致了在单字节字符继续下N能继续标识字符串的字节长度，但是在多字节的字符集条件下，N不一定是字节长度。</p><p>因此，在不同的字符集下，CHAR类型存储的字符串的长度是不固定的，所以<strong>对于多字节的字符集下的CHAR类型，InnoDB存储引擎会将其视为变长字符串来进行存储</strong>。</p><h3 id="innodb数据页结构" tabindex="-1"><a class="header-anchor" href="#innodb数据页结构"><span>InnoDB数据页结构</span></a></h3><p><span alt="solid">页类型为B-tree Node的页存放的就是表中行的实际数据</span>。</p><p>InnDB数据页由7个部分组成，如下图所示：</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250512215643902.png" alt="image-20250512215643902"></p><h4 id="file-header" tabindex="-1"><a class="header-anchor" href="#file-header"><span>File Header</span></a></h4><p>File Header用来记录页的一些头信息，共占据38个字节。</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250512215946770.png" alt="image-20250512215946770"></p><h4 id="page-header" tabindex="-1"><a class="header-anchor" href="#page-header"><span>Page Header</span></a></h4><p>Page Header用来记录数据的状态信息，共占用56个字节。</p><p><img src="https://typora-panhao.oss-cn-hangzhou.aliyuncs.com/image-20250512220234149.png" alt="image-20250512220234149"></p><h4 id="infimum-和-supremum-record" tabindex="-1"><a class="header-anchor" href="#infimum-和-supremum-record"><span>Infimum 和 Supremum Record</span></a></h4><p>Infimum Record和Supremum Record用InnoDB存储引擎用来限定边界的虚拟记录，InnoDB会在每个页创建的时候生成这个两条记录，并且在任何时候都不允许被删除。</p><ul><li>Infimum Record —— 记录比该页中任何主键都要小的值；</li><li>Supremum Record —— 记录比该页中任何可能大的值还要大的值；</li></ul><h4 id="user-record-和-free-space" tabindex="-1"><a class="header-anchor" href="#user-record-和-free-space"><span>User Record 和 Free Space</span></a></h4><p>User Record 就是利用来实际记录数据的部分，InnoDB存储引擎表总是B+树索引组织的。</p><p>Free Space 就是指空闲空间，同样也是个链表数据结构，在一条记录被删除后，该空间会被加入到空闲列表中；</p><h4 id="page-directory" tabindex="-1"><a class="header-anchor" href="#page-directory"><span>Page Directory</span></a></h4><p>Page Directory 中存放了记录的相对位置，记录的指针被称为slot（槽），InnoDB的存储引擎是一个稀疏目录，即一个槽中可以包含多个记录。</p><p>稀疏目录的意思是它并不会为每条记录都创建一个槽，它会给比较关键的记录（<em>特殊的主键或者按照固定间隔的主键</em>）创建槽，这是一种时间换空间的做法。</p><p>InnoDB存储引擎在查询数据的时候先定位到在哪个页中，然后再在稀疏目录中通过二分查找法找到要查询的槽，然后从该槽开始往后扫描直到找到对应的数据。</p><h4 id="file-trailer" tabindex="-1"><a class="header-anchor" href="#file-trailer"><span>File Trailer</span></a></h4><p>File Trailer用来标识页是否已经完整的写入磁盘了。File Trailer 占据8个字节，前面4个字节代表该页的checksum值，后面4个字节与File Header中的<code>FIL_PAGE_LSN</code>的值相同。</p><p>InnoDB存储引擎在比较的时候通过checksum函数来比较与File Header中对应字段的值是否一致，如果是，则表示当前页已经被完整的写入磁盘了；反之，则没有被完整的写入磁盘中。</p><p>InnoDB存储引擎每次从磁盘中加载页的时候都会来校验页的完整性，而校验页的完整性就依赖于File Trailer。</p><h3 id="named-file-formats-机制" tabindex="-1"><a class="header-anchor" href="#named-file-formats-机制"><span>Named File Formats 机制</span></a></h3><p>Named FileFormats机制的作用就是解决不同版本下页的兼容性问题。</p><p>实现的方式就是：<span alt="solid">新的文件格式总是包含之前版本的页格式</span>，未来版本中InnoDB存储引擎还将引入新的文件格式（<em>以动物的名称来命名</em>）。</p><p>可以使用下面的SQL语句来查看InnoDB存储引擎的文件格式：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;innodb_file_format&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果出现不支持的文件格式，可以在MySQL的错误日志中观察到相应的提示信息。</p><h3 id="约束" tabindex="-1"><a class="header-anchor" href="#约束"><span>约束</span></a></h3><p>约束是数据库提供的一种机制，它的主要作用就是用来保证数据的完整性。</p><h4 id="数据的完整性" tabindex="-1"><a class="header-anchor" href="#数据的完整性"><span>数据的完整性</span></a></h4><p>数据完整性一共有三种形式：</p><ol><li>实体完整性 —— 表中必须要有一个主键，例如显式地定义一个Primary Key；</li><li>域完整性 —— 每列的值都需要满足特定的条件，例如选择合适的数据类型；</li><li>参照完整性 —— 保证两张表之间的关系，例如外键；</li></ol><h4 id="约束的创建和查找" tabindex="-1"><a class="header-anchor" href="#约束的创建和查找"><span>约束的创建和查找</span></a></h4><p>约束创建的两种方式：</p><ul><li>在表创建的时候就进行约束定义；</li><li>使用<code>Alter TABLE</code>命令来进行创建约束；</li></ul><blockquote><p>⭐<strong>约束和索引的区别</strong></p><p>约束是一个逻辑上的概念，主要用来保证数据的完整性；索引是一个数据结构，由逻辑上的概念也代表着物理存储的方式。</p></blockquote><h4 id="对于错误数据的约束" tabindex="-1"><a class="header-anchor" href="#对于错误数据的约束"><span>对于错误数据的约束</span></a></h4><p>MySQL数据允许非法或者不正确的数据插入或更新，例如向NOT NULL的列中插入一个NULL值，MySQL会将其转成0插入到列中，因此数据本身没有对数据的正确性进行约束。</p><p>如果用户向通过约束对于数据的非法数据的插入或更新，必须设置参数<code>sql_mode</code>。</p><h4 id="enum和set约束" tabindex="-1"><a class="header-anchor" href="#enum和set约束"><span>ENUM和SET约束</span></a></h4><p>传统的数据库中存在CHECK约束，用于对数据的值进行校验，例如校验某列的值必须大于10小于20等。MySQL本身并不支持传统的CHECK约束，但是它可以通过ENUM约束和SET约束来实现CHECK约束中的部分功能。</p><ul><li>SET约束 —— 限制该列中值的取值范围，必须是固定的枚举值的一个或多个（<em>插入时如果是多个，中间用逗号分隔</em>）；</li><li>ENUM约束 —— 限制该列中值的取值范围，必须是固定的枚举值中的一个。</li></ul><h4 id="触发器与约束" tabindex="-1"><a class="header-anchor" href="#触发器与约束"><span>触发器与约束</span></a></h4><p>触发器是指在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程，最多可以为一个表设置6个触发器（<em>三种操作之前或之后触发</em>）。</p><p>在电商项目中，用户支付的时候都是需要对余额进行扣减，如果此时因为程序的错误导致扣减的是负数，最终就会导致用户的余额反而增加了。针对这种场景，我们就可以在MySQL中创建触发其，让其在更新之前进行值的检查。</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token comment"># 设置结束符</span></span>
<span class="line"><span class="token keyword">delimiter</span> $$<span class="token punctuation">;</span></span>
<span class="line"><span class="token comment"># 创建触发器</span></span>
<span class="line"><span class="token keyword">create</span> <span class="token keyword">trigger</span> tgr_usercash_update before <span class="token keyword">update</span> <span class="token keyword">on</span> usercash <span class="token keyword">for each row</span></span>
<span class="line"><span class="token keyword">begin</span></span>
<span class="line"><span class="token keyword">if</span> new<span class="token punctuation">.</span>cash <span class="token operator">-</span> old<span class="token punctuation">.</span>cash <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">then</span></span>
<span class="line">inser <span class="token keyword">into</span> usercash_err_log <span class="token keyword">select</span> old<span class="token punctuation">.</span>userid<span class="token punctuation">,</span>old<span class="token punctuation">.</span>cash<span class="token punctuation">.</span>new<span class="token punctuation">.</span>cash<span class="token punctuation">,</span><span class="token keyword">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">set</span> new<span class="token punctuation">.</span>cash <span class="token operator">=</span> old<span class="token punctuation">.</span>cash<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">end</span></span>
<span class="line">$$</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="外键约束" tabindex="-1"><a class="header-anchor" href="#外键约束"><span>外键约束</span></a></h4><p>外键约束是用来保证参照完整性的。MyISAM存储引擎不支持外键，但是InnoDB存储引擎是支持完整的外键约束。</p><p>一般来说被引用的表称之为父表，引用的表称为子表。外键在定义的时候可以指定在父表执行DELTE或UPDATE的时候，子表需要执行的操作，可选项有：</p><ul><li>CASCADE —— 相应的子表中的数据也进行DELTE或UPDATE；</li><li>SET NULL —— 相应的子表中的数据被更新为NULL值；</li><li>NO ACTION —— 抛出错误，不允许这类操作的发生；</li><li>RESTRICT —— 抛出错误，不允许这类操作的发生（<em>默认策略</em>）；</li></ul><p>可以使用如下的语句来设置策略：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> child_table <span class="token punctuation">(</span></span>
<span class="line">    child_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span></span>
<span class="line">    parent_id <span class="token keyword">INT</span><span class="token punctuation">,</span></span>
<span class="line">    other_columns <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>parent_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> parent_table<span class="token punctuation">(</span>parent_id<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> {<span class="token keyword">RESTRICT</span> <span class="token operator">|</span> <span class="token keyword">CASCADE</span> <span class="token operator">|</span> <span class="token keyword">SET</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token keyword">NO</span> <span class="token keyword">ACTION</span> <span class="token operator">|</span> <span class="token keyword">SET</span> <span class="token keyword">DEFAULT</span>}</span>
<span class="line">    <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> {<span class="token keyword">RESTRICT</span> <span class="token operator">|</span> <span class="token keyword">CASCADE</span> <span class="token operator">|</span> <span class="token keyword">SET</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token keyword">NO</span> <span class="token keyword">ACTION</span> <span class="token operator">|</span> <span class="token keyword">SET</span> <span class="token keyword">DEFAULT</span>}</span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,234))])}const k=i(c,[["render",h]]),b=JSON.parse('{"path":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html","title":"MySQL体系结构和存储引擎","lang":"zh-CN","frontmatter":{"date":"2025-05-10T00:00:00.000Z","category":["数据库"],"tag":["MySQL"],"archive":false},"headers":[{"level":2,"title":"MySQL体系结构","slug":"mysql体系结构","link":"#mysql体系结构","children":[]},{"level":2,"title":"MySQL的存储引擎","slug":"mysql的存储引擎","link":"#mysql的存储引擎","children":[{"level":3,"title":"InnoDB与MySIAM之间的区别","slug":"innodb与mysiam之间的区别","link":"#innodb与mysiam之间的区别","children":[]}]},{"level":2,"title":"InnoDB存储引擎体系结构","slug":"innodb存储引擎体系结构","link":"#innodb存储引擎体系结构","children":[{"level":3,"title":"后台线程","slug":"后台线程","link":"#后台线程","children":[]},{"level":3,"title":"内存","slug":"内存","link":"#内存","children":[]}]},{"level":2,"title":"CheckPoint技术","slug":"checkpoint技术","link":"#checkpoint技术","children":[{"level":3,"title":"InnoDB中CheckPoint触发","slug":"innodb中checkpoint触发","link":"#innodb中checkpoint触发","children":[]}]},{"level":2,"title":"InnoDB的关键特性","slug":"innodb的关键特性","link":"#innodb的关键特性","children":[{"level":3,"title":"插入缓冲","slug":"插入缓冲","link":"#插入缓冲","children":[]},{"level":3,"title":"两次写","slug":"两次写","link":"#两次写","children":[]},{"level":3,"title":"自适应Hash索引","slug":"自适应hash索引","link":"#自适应hash索引","children":[]},{"level":3,"title":"异步IO","slug":"异步io","link":"#异步io","children":[]},{"level":3,"title":"刷新邻接页","slug":"刷新邻接页","link":"#刷新邻接页","children":[]}]},{"level":2,"title":"参数文件","slug":"参数文件","link":"#参数文件","children":[{"level":3,"title":"参数类型","slug":"参数类型","link":"#参数类型","children":[]}]},{"level":2,"title":"日志文件","slug":"日志文件","link":"#日志文件","children":[{"level":3,"title":"错误日志","slug":"错误日志","link":"#错误日志","children":[]},{"level":3,"title":"慢查询日志","slug":"慢查询日志","link":"#慢查询日志","children":[]},{"level":3,"title":"查询日志","slug":"查询日志","link":"#查询日志","children":[]},{"level":3,"title":"二进制日志","slug":"二进制日志","link":"#二进制日志","children":[]}]},{"level":2,"title":"套接字文件","slug":"套接字文件","link":"#套接字文件","children":[]},{"level":2,"title":"Pid文件","slug":"pid文件","link":"#pid文件","children":[]},{"level":2,"title":"表结构定义文件","slug":"表结构定义文件","link":"#表结构定义文件","children":[]},{"level":2,"title":"InnoDB存储引擎文件","slug":"innodb存储引擎文件","link":"#innodb存储引擎文件","children":[{"level":3,"title":"表空间文件","slug":"表空间文件","link":"#表空间文件","children":[]},{"level":3,"title":"重做日志文件","slug":"重做日志文件","link":"#重做日志文件","children":[]}]},{"level":2,"title":"索引组织表","slug":"索引组织表","link":"#索引组织表","children":[]},{"level":2,"title":"InnoDB的逻辑存储结构","slug":"innodb的逻辑存储结构","link":"#innodb的逻辑存储结构","children":[{"level":3,"title":"表空间","slug":"表空间","link":"#表空间","children":[]}]},{"level":2,"title":"InnoDB行记录格式","slug":"innodb行记录格式","link":"#innodb行记录格式","children":[{"level":3,"title":"Compact行记录格式","slug":"compact行记录格式","link":"#compact行记录格式","children":[]},{"level":3,"title":"行溢出数据","slug":"行溢出数据","link":"#行溢出数据","children":[]},{"level":3,"title":"Dynamic行记录格式","slug":"dynamic行记录格式","link":"#dynamic行记录格式","children":[]},{"level":3,"title":"CHAR的行结构存储","slug":"char的行结构存储","link":"#char的行结构存储","children":[]},{"level":3,"title":"InnoDB数据页结构","slug":"innodb数据页结构","link":"#innodb数据页结构","children":[]},{"level":3,"title":"Named File Formats 机制","slug":"named-file-formats-机制","link":"#named-file-formats-机制","children":[]},{"level":3,"title":"约束","slug":"约束","link":"#约束","children":[]}]}],"git":{},"filePathRelative":"posts/数据库/MySQL体系结构和存储引擎.md","excerpt":"\\n<h2>MySQL体系结构</h2>\\n<p>数据库是由一个一个的文件组成的，而对实际的数据进行增删改查的操作则需要数据库实例来完成。</p>\\n"}');export{k as comp,b as data};
